{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"window.React\"","webpack:///./node_modules/prop-types/index.js","webpack:///external \"window.reactR\"","webpack:///./node_modules/prop-types/factoryWithThrowingShims.js","webpack:///./node_modules/prop-types/lib/ReactPropTypesSecret.js","webpack:///../node_modules/babel-plugin-transform-async-to-promises/helpers.js","webpack:///../src/index.js","webpack:///./srcjs/Test.js","webpack:///./srcjs/AudioReactRecorder.jsx"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","window","React","require","reactR","ReactPropTypesSecret","emptyFunction","emptyFunctionWithReset","resetWarningCache","shim","props","propName","componentName","location","propFullName","secret","err","Error","getShim","isRequired","ReactPropTypes","array","bigint","bool","func","number","string","symbol","any","arrayOf","element","elementType","instanceOf","node","objectOf","oneOf","oneOfType","shape","exact","checkPropTypes","PropTypes","iterator","asyncIterator","RecordState","freeze","START","PAUSE","STOP","NONE","AudioReactRecorder","_this","init","leftchannel","rightchannel","recorder","recording","recordingLength","volume","audioInput","sampleRate","AudioContext","webkitAudioContext","context","analyser","canvas","canvasRef","current","canvasCtx","getContext","stream","tested","navigator","getUserMedia","webkitGetUserMedia","mozGetUserMedia","getStream","constraints","audio","video","mediaDevices","setUpRecording","createGain","createMediaStreamSource","createAnalyser","connect","createScriptProcessor","destination","self","onaudioprocess","e","left","inputBuffer","getChannelData","right","reduce","a","b","console","log","stop","getTracks","forEach","track","close","push","Float32Array","visualize","mergeBuffers","channelBuffer","result","offset","lng","length","buffer","set","interleave","leftChannel","rightChannel","inputIndex","index","writeUTFBytes","view","setUint8","charCodeAt","WIDTH","width","HEIGHT","height","CENTERX","CENTERY","fftSize","dataArray","Uint8Array","frequencyBinCount","DATA","LEN","h","x","clearRect","getByteTimeDomainData","fillStyle","fillRect","innerWidth","innerHeight","draw","cancelAnimationFrame","drawVisual","requestAnimationFrame","imgData","getImageData","putImageData","getByteFrequencyData","rat","hue","Math","round","lit","beginPath","strokeStyle","moveTo","lineTo","stroke","setupMic","body","recover","then","start","onStop","type","closeMic","leftBuffer","rightBuffer","interleaved","ArrayBuffer","DataView","setUint32","setUint16","setInt16","blob","Blob","audioUrl","URL","createObjectURL","url","pause","resume","getAudioTracks","disconnect","createRef","componentDidMount","this","componentDidUpdate","prevProps","prevState","state","checkState","previousState","doIfState","cb","componentWillUnmount","render","canvasWidth","canvasHeight","className","id","ref","Component","propTypes","backgroundColor","foregroundColor","defaultProps","Test","useState","recordState","setRecordState","setAudioUrl","audioData","onClick","src","controls","reactWidget","AudioReactRecorderCustom"],"mappings":"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","file":"AudioReactRecorder.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","module.exports = window.React;","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (process.env.NODE_ENV !== 'production') {\n  var ReactIs = require('react-is');\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = require('./factoryWithTypeCheckers')(ReactIs.isElement, throwOnDirectAccess);\n} else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = require('./factoryWithThrowingShims')();\n}\n","module.exports = window.reactR;","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');\n\nfunction emptyFunction() {}\nfunction emptyFunctionWithReset() {}\nemptyFunctionWithReset.resetWarningCache = emptyFunction;\n\nmodule.exports = function() {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret) {\n      // It is still safe when called from React.\n      return;\n    }\n    var err = new Error(\n      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n      'Use PropTypes.checkPropTypes() to call them. ' +\n      'Read more at http://fb.me/use-check-prop-types'\n    );\n    err.name = 'Invariant Violation';\n    throw err;\n  };\n  shim.isRequired = shim;\n  function getShim() {\n    return shim;\n  };\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n  var ReactPropTypes = {\n    array: shim,\n    bigint: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    elementType: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim,\n\n    checkPropTypes: emptyFunctionWithReset,\n    resetWarningCache: emptyFunction\n  };\n\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import React from 'react'\nimport styles from './styles.module.css'\nimport PropTypes from 'prop-types' // ES6\n\n// export const AudioReactRecorder = ({ text }) => {\n//   return <div className={styles.test}>BULLSWEET: {text}</div>\n// }\n\nexport const RecordState = Object.freeze({\n  START: 'start',\n  PAUSE: 'pause',\n  STOP: 'stop',\n  NONE: 'none'\n})\n\nexport default class AudioReactRecorder extends React.Component {\n  //0 - constructor\n  constructor(props) {\n    super(props)\n\n    this.canvasRef = React.createRef()\n  }\n\n  //TODO: add the props definitions\n  static propTypes = {\n    state: PropTypes.string,\n    type: PropTypes.string.isRequired,\n    backgroundColor: PropTypes.string,\n    foregroundColor: PropTypes.string,\n    canvasWidth: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    canvasHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n\n    //method calls\n    onStop: PropTypes.func\n  }\n  static defaultProps = {\n    state: RecordState.NONE,\n    type: 'audio/wav',\n    backgroundColor: 'hsl(280, 100%, 10%)',\n    foregroundColor: 'rgb(0, 0, 0)',\n    canvasWidth: window.innerWidth,\n    canvasHeight: 400\n  }\n\n  //2 - mount\n  componentDidMount() {\n    this.init()\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    const { state } = this.props\n\n    this.checkState(prevProps.state, state)\n  }\n\n  checkState(previousState) {\n    switch (previousState) {\n      case RecordState.START:\n        this.doIfState(RecordState.PAUSE, this.pause)\n        this.doIfState(RecordState.STOP, this.stop)\n        break\n      case RecordState.PAUSE:\n        this.doIfState(RecordState.START, this.resume)\n        this.doIfState(RecordState.STOP, this.stop)\n        break\n      case RecordState.STOP:\n        this.doIfState(RecordState.START, this.start)\n        break\n      default:\n        this.doIfState(RecordState.START, this.start)\n        break\n    }\n  }\n\n  doIfState(state, cb) {\n    if (this.props.state == state) {\n      cb && cb()\n    }\n  }\n\n  //TODO: destroy request animation frame\n  componentWillUnmount() {}\n\n  //TODO: change to state some conditionals\n  init = async () => {\n    this.leftchannel = []\n    this.rightchannel = []\n    this.recorder = null\n    this.recording = false\n    this.recordingLength = 0\n    this.volume = null\n    this.audioInput = null\n    this.sampleRate = null\n    this.AudioContext = window.AudioContext || window.webkitAudioContext\n    this.context = null\n    this.analyser = null\n    this.freeze = false\n    this.canvas = this.canvasRef.current\n    this.canvasCtx = this.canvas.getContext('2d')\n    this.stream = null\n    this.tested = false\n\n    navigator.getUserMedia =\n      navigator.getUserMedia ||\n      navigator.webkitGetUserMedia ||\n      navigator.mozGetUserMedia\n  }\n\n  //get mic stream\n  getStream = (constraints) => {\n    if (!constraints) {\n      constraints = { audio: true, video: false }\n    }\n\n    return navigator.mediaDevices.getUserMedia(constraints)\n  }\n\n  setUpRecording = () => {\n    this.context = new this.AudioContext()\n    this.sampleRate = this.context.sampleRate\n\n    // creates a gain node\n    this.volume = this.context.createGain()\n\n    // creates an audio node from teh microphone incoming stream\n    this.audioInput = this.context.createMediaStreamSource(this.stream)\n\n    // Create analyser\n    this.analyser = this.context.createAnalyser()\n\n    // connect audio input to the analyser\n    this.audioInput.connect(this.analyser)\n\n    // connect analyser to the volume control\n    // analyser.connect(volume);\n\n    let bufferSize = 2048\n    this.recorder = this.context.createScriptProcessor(bufferSize, 2, 2)\n\n    // we connect the volume control to the processor\n    // volume.connect(recorder);\n\n    this.analyser.connect(this.recorder)\n\n    // finally connect the processor to the output\n    this.recorder.connect(this.context.destination)\n\n    const self = this\n    this.recorder.onaudioprocess = function (e) {\n      // Check\n      if (!self.recording) return\n      // Do something with the data, i.e Convert this to WAV\n      let left = e.inputBuffer.getChannelData(0)\n      let right = e.inputBuffer.getChannelData(1)\n      if (!self.tested) {\n        self.tested = true\n        // if this reduces to 0 we are not getting any sound\n        if (!left.reduce((a, b) => a + b)) {\n          console.log('Error: There seems to be an issue with your Mic')\n          // clean up;\n          self.stop()\n          self.stream.getTracks().forEach(function (track) {\n            track.stop()\n          })\n          self.context.close()\n        }\n      }\n      // we clone the samples\n      self.leftchannel.push(new Float32Array(left))\n      self.rightchannel.push(new Float32Array(right))\n      self.recordingLength += bufferSize\n\n    }\n\n      this.visualize()\n\n  }\n\n  mergeBuffers = (channelBuffer, recordingLength) => {\n    let result = new Float32Array(recordingLength)\n    let offset = 0\n    let lng = channelBuffer.length\n    for (let i = 0; i < lng; i++) {\n      let buffer = channelBuffer[i]\n      result.set(buffer, offset)\n      offset += buffer.length\n    }\n    return result\n  }\n\n  interleave = (leftChannel, rightChannel) => {\n    let length = leftChannel.length + rightChannel.length\n    let result = new Float32Array(length)\n\n    let inputIndex = 0\n\n    for (let index = 0; index < length; ) {\n      result[index++] = leftChannel[inputIndex]\n      result[index++] = rightChannel[inputIndex]\n      inputIndex++\n    }\n    return result\n  }\n\n  writeUTFBytes = (view, offset, string) => {\n    let lng = string.length\n    for (let i = 0; i < lng; i++) {\n      view.setUint8(offset + i, string.charCodeAt(i))\n    }\n  }\n\n  visualize = () => {\n    const { backgroundColor, foregroundColor } = this.props\n\n    this.WIDTH = this.canvas.width\n    this.HEIGHT = this.canvas.height\n    this.CENTERX = this.canvas.width / 2\n    this.CENTERY = this.canvas.height / 2\n\n    if (!this.analyser) {\n      return null;\n    } else {\n\n    this.analyser.fftSize = 4096\n    const bufferLength = this.analyser.fftSize\n    const dataArray = new Uint8Array(this.analyser.frequencyBinCount)\n    const DATA = new Uint8Array(this.analyser.frequencyBinCount);\n    const LEN = DATA.length;\n    const h = this.HEIGHT / LEN;\n    const x = this.WIDTH - 1;\n\n    this.canvasCtx.clearRect(0, 0, this.WIDTH, this.HEIGHT)\n\n    //reference this using self\n    let self = this\n\n    self.analyser.getByteTimeDomainData(dataArray)\n    self.canvasCtx.fillStyle = 'hsl(270, 31%, 14%)'\n    self.canvasCtx.fillRect(0, 0, self.WIDTH = window.innerWidth, self.HEIGHT = window.innerHeight)\n\n    const draw = function () {\n\n      if(!self.freeze) {\n        cancelAnimationFrame(self.drawVisual)\n      }\n      self.drawVisual = requestAnimationFrame(draw)\n\n      if(!self.freeze) {\n\n        let imgData = self.canvasCtx.getImageData(1, 0, self.WIDTH = window.innerWidth - 1, self.HEIGHT = window.innerHeight);\n        self.canvasCtx.fillRect(0, 0, self.WIDTH = window.innerWidth - 1, self.HEIGHT = window.innerHeight);\n        self.canvasCtx.putImageData(imgData, 0, 0);\n        self.analyser.getByteFrequencyData(DATA);\n        for (let i = 0; i < LEN; i++) {\n          let rat = DATA[i] / 255;\n          let hue = Math.round((rat * 120) + 280 % 360);\n          let sat = '100%';\n          let lit = 10 + (70 * rat) + '%';\n          self.canvasCtx.beginPath();\n          self.canvasCtx.strokeStyle = `hsl(${hue}, ${sat}, ${lit})`;\n          self.canvasCtx.moveTo(x, self.canvas.height - (i * h));\n          self.canvasCtx.lineTo(x, self.canvas.height - (i * h + h));\n          self.canvasCtx.stroke();\n        }\n\n      } \n\n    }\n\n      draw()\n\n    }\n  }\n\n  setupMic = async () => {\n    //TODO: only get stream after clicking start\n    try {\n      window.stream = this.stream = await this.getStream()\n      //TODO: on got stream\n    } catch (err) {\n      //TODO: error getting stream\n      console.log('Error: Issue getting mic', err)\n    }\n\n    this.setUpRecording()\n  }\n\n  start = async () => {\n    await this.setupMic()\n\n    this.recording = true\n    this.freeze = false\n    // reset the buffers for the new recording\n    this.leftchannel.length = this.rightchannel.length = 0\n    this.recordingLength = 0\n  }\n\n  stop = () => {\n    const { onStop, type } = this.props\n\n    this.recording = false\n    this.freeze = true\n    this.closeMic()\n\n    // we flat the left and right channels down\n    this.leftBuffer = this.mergeBuffers(this.leftchannel, this.recordingLength)\n    this.rightBuffer = this.mergeBuffers(\n      this.rightchannel,\n      this.recordingLength\n    )\n    // we interleave both channels together\n    let interleaved = this.interleave(this.leftBuffer, this.rightBuffer)\n\n    ///////////// WAV Encode /////////////////\n    // from http://typedarray.org/from-microphone-to-wav-with-getusermedia-and-web-audio/\n    //\n\n    // we create our wav file\n    let buffer = new ArrayBuffer(44 + interleaved.length * 2)\n    let view = new DataView(buffer)\n\n    // RIFF chunk descriptor\n    this.writeUTFBytes(view, 0, 'RIFF')\n    view.setUint32(4, 44 + interleaved.length * 2, true)\n    this.writeUTFBytes(view, 8, 'WAVE')\n    // FMT sub-chunk\n    this.writeUTFBytes(view, 12, 'fmt ')\n    view.setUint32(16, 16, true)\n    view.setUint16(20, 1, true)\n    // stereo (2 channels)\n    view.setUint16(22, 2, true)\n    view.setUint32(24, this.sampleRate, true)\n    view.setUint32(28, this.sampleRate * 4, true)\n    view.setUint16(32, 4, true)\n    view.setUint16(34, 16, true)\n    // data sub-chunk\n    this.writeUTFBytes(view, 36, 'data')\n    view.setUint32(40, interleaved.length * 2, true)\n\n    // write the PCM samples\n    let lng = interleaved.length\n    let index = 44\n    let volume = 1\n    for (let i = 0; i < lng; i++) {\n      view.setInt16(index, interleaved[i] * (0x7fff * volume), true)\n      index += 2\n    }\n\n    // our final binary blob\n    const blob = new Blob([view], { type: type })\n    const audioUrl = URL.createObjectURL(blob)\n\n    onStop &&\n      onStop({\n        blob: blob,\n        url: audioUrl,\n        type\n      })\n\n      this.analyser = null\n\n  }\n\n  pause = () => {\n    this.recording = false\n    this.closeMic()\n  }\n\n  resume = () => {\n    this.setupMic()\n    this.recording = true\n  }\n\n  closeMic = () => {\n    this.stream.getAudioTracks().forEach((track) => {\n      track.stop()\n    })\n    this.audioInput.disconnect(0)\n    this.analyser.disconnect(0)\n    this.recorder.disconnect(0)\n  }\n\n  //1 - render\n  render() {\n    const { canvasWidth, canvasHeight } = this.props\n\n    return (\n      <div className='audio-react-recorder'>\n        <canvas \n          id='spectogram'\n          ref={this.canvasRef}\n          width={canvasWidth}\n          height={canvasHeight}\n          className='audio-react-recorder__canvas'\n        ></canvas>\n      </div>\n    )\n  }\n}\n","import React, { useState } from 'react'\nimport AudioReactRecorder, { RecordState } from 'audio-react-recorder'\n\nfunction Test(){\n\n    const [recordState, setRecordState] = useState(RecordState.NONE);\n    const [audioUrl, setAudioUrl] = useState(null);\n\n    const start = (audioData) => {\n        setRecordState(RecordState.START)\n        console.log('start');\n        console.log(audioData.url);\n      }\n\n    const stop = () => {\n        setRecordState(RecordState.STOP)\n        console.log('stop');\n      }\n\n      //audioData contains blob and blobUrl\n    const  onStop = (audioData) => {\n        console.log('audioData', audioData)\n        console.log('Url', audioData.url)\n        setAudioUrl(audioData.url)\n    }\n\n    return(\n      <div>\n\n        <AudioReactRecorder state={recordState} onStop={onStop} />\n\n        <button onClick={start}>Start</button>\n        <button onClick={stop}>Stop</button>\n\n        <audio src={audioUrl} controls=\"controls\" />\n      </div>\n    );\n}\n\n\nexport default Test;\n","import AudioReactRecorder, { RecordState } from 'audio-react-recorder'\nimport { reactWidget } from 'reactR';\nimport Test from './Test.js';\n\n\nreactWidget('AudioReactRecorder', 'output', {\n  AudioReactRecorderCustom: Test\n});\n"],"sourceRoot":""}